#include "motor_shield_v1.h"

#define DC_MOTOR_MIN 0
#define DC_MOTOR_MAX 999
// #define MAX_FACTOR 1.0f
// #define MIN_FACTOR 0.05f
#define MIN_START_POWER 0.1f  // Minimum power to overcome static friction

/* Motor_Shield_V1 Configuration--------------------------------------------------------*/

// Declare a Motor_Shield_V1 structure with the defined ports and pins
Motor_Shield_V1 motor_shield_v1;
Motor_Shield_L29XX motor_shield_l29xx;

// Initialize the motor shield
void ms_init(enum Motor_Shield_Type type, bool enable_pwm)
{
    if (type == MS_V1) {
        // If using Motor Shield V1
        // Initialize the HC595 pins
        gpio_pin_set(&motor_shield_v1.hc595.LATCH, GPIOA, GPIO_PIN_6);
        gpio_pin_set(&motor_shield_v1.hc595.CLOCK, GPIOB, GPIO_PIN_5);
        gpio_pin_set(&motor_shield_v1.hc595.DATA, GPIOA, GPIO_PIN_9);

        // Set the forward and reverse of each motor
        // motor_shield_v1.M1.reverse = false;
        // motor_shield_v1.M2.reverse = false;
        // motor_shield_v1.M3.reverse = false;
        // motor_shield_v1.M4.reverse = false;

        for (uint8_t i = M1; i <= M4; i++) {
            get_dc_motor(&motor_shield_v1, MS_V1, i)->EN.soft_control_delay = CreateNonBlockingDelay();
        }

        // Initialize the servos with pwm_constructor function
        // Since NUCLEO-L053R8 has insufficient PWM output on the servo pwm pin of motor shield v1, \
        the timers and channels for servo pwm need to be self-defined.
        motor_shield_v1.S1_PWM = servo[S1];
        motor_shield_v1.S2_PWM = servo[S2];
    } else if (type == MS_L29XX) {
        gpio_pin_set(&motor_shield_l29xx.M1.IN1, GPIOB, GPIO_PIN_1);  // M1_IN1: PB1
        gpio_pin_set(&motor_shield_l29xx.M1.IN2, GPIOB, GPIO_PIN_2);  // M1_IN2: PB2
        gpio_pin_set(&motor_shield_l29xx.M2.IN1, GPIOC, GPIO_PIN_4);  // M2_IN1: PC4
        gpio_pin_set(&motor_shield_l29xx.M2.IN2, GPIOB, GPIO_PIN_15); // M2_IN2: PB15
        gpio_pin_set(&motor_shield_l29xx.M3.IN1, GPIOA, GPIO_PIN_12); // M3_IN1: PA12
        gpio_pin_set(&motor_shield_l29xx.M3.IN2, GPIOC, GPIO_PIN_5);  // M3_IN2: PC5
        gpio_pin_set(&motor_shield_l29xx.M4.IN1, GPIOB, GPIO_PIN_12); // M4_IN1: PB12
        gpio_pin_set(&motor_shield_l29xx.M4.IN2, GPIOA, GPIO_PIN_11); // M4_IN2: PA11

        // Set the forward and reverse of each motor
        motor_shield_l29xx.M1.reverse = false;
        motor_shield_l29xx.M2.reverse = true;
        motor_shield_l29xx.M3.reverse = false;
        motor_shield_l29xx.M4.reverse = false;

        for (uint8_t i = M1; i <= M4; i++) {
            get_dc_motor(&motor_shield_l29xx, MS_L29XX, i)->EN.soft_control_delay = CreateNonBlockingDelay();
        }
    }

    if (enable_pwm) {
        // If using PWM mode
        ms_pwm_init(type); // Call the ms_pwm_init function with the type parameter
    } else {
        // If using GPIO mode
        ms_gpio_init(type); // Call the ms_gpio_init function with the type parameter
    }
}

// Initialize the PWM mode for the motor shield
void ms_pwm_init(enum Motor_Shield_Type type)
{
    if (type == MS_V1) {
        // If using Motor Shield V1
        // The timers are for NUCLEO-L053R8.
        motor_shield_v1.M1.EN.PWM = pwm_constructor((PWM_TypeDef) {
            .timer = &htim22, .channel = TIM_CHANNEL_2, .pwm_min = DC_MOTOR_MIN, .pwm_max = DC_MOTOR_MAX, .physical_min = DC_MOTOR_MIN, .physical_max = DC_MOTOR_MAX, .offset = 0, .pwm_value = 0, .reverse = false, .complementary = false, .latch = false
        });
        motor_shield_v1.M2.EN.PWM = pwm_constructor((PWM_TypeDef) {
            .timer = &htim2, .channel = TIM_CHANNEL_2, .pwm_min = DC_MOTOR_MIN, .pwm_max = DC_MOTOR_MAX, .physical_min = DC_MOTOR_MIN, .physical_max = DC_MOTOR_MAX, .offset = 0, .pwm_value = 0, .reverse = false, .complementary = false, .latch = false
        });
        motor_shield_v1.M3.EN.PWM = pwm_constructor((PWM_TypeDef) {
            .timer = &htim2, .channel = TIM_CHANNEL_3, .pwm_min = DC_MOTOR_MIN, .pwm_max = DC_MOTOR_MAX, .physical_min = DC_MOTOR_MIN, .physical_max = DC_MOTOR_MAX, .offset = 0, .pwm_value = 0, .reverse = false, .complementary = false, .latch = false
        });
        motor_shield_v1.M4.EN.PWM = pwm_constructor((PWM_TypeDef) {
            .timer = &htim22, .channel = TIM_CHANNEL_1, .pwm_min = DC_MOTOR_MIN, .pwm_max = DC_MOTOR_MAX, .physical_min = DC_MOTOR_MIN, .physical_max = DC_MOTOR_MAX, .offset = 0, .pwm_value = 0, .reverse = false, .complementary = false, .latch = false
        });

        motor_shield_v1.M1.EN.enable_pwm = true;
        motor_shield_v1.M2.EN.enable_pwm = true;
        motor_shield_v1.M3.EN.enable_pwm = true;
        motor_shield_v1.M4.EN.enable_pwm = true;
    } else if (type == MS_L29XX) {
        // If using Motor Shield L29XX
        // The timers are for NUCLEO-L053R8.
        motor_shield_l29xx.M1.EN.PWM = pwm_constructor((PWM_TypeDef) {
            .timer = &htim2, .channel = TIM_CHANNEL_2, .pwm_min = DC_MOTOR_MIN, .pwm_max = DC_MOTOR_MAX, .physical_min = DC_MOTOR_MIN, .physical_max = DC_MOTOR_MAX, .offset = 0, .pwm_value = 0, .reverse = false, .complementary = false, .latch = false
        });
        motor_shield_l29xx.M2.EN.PWM = pwm_constructor((PWM_TypeDef) {
            .timer = &htim22, .channel = TIM_CHANNEL_2, .pwm_min = DC_MOTOR_MIN, .pwm_max = DC_MOTOR_MAX, .physical_min = DC_MOTOR_MIN, .physical_max = DC_MOTOR_MAX, .offset = 0, .pwm_value = 0, .reverse = false, .complementary = false, .latch = false
        });
        motor_shield_l29xx.M3.EN.PWM = pwm_constructor((PWM_TypeDef) {
            .timer = &htim22, .channel = TIM_CHANNEL_1, .pwm_min = DC_MOTOR_MIN, .pwm_max = DC_MOTOR_MAX, .physical_min = DC_MOTOR_MIN, .physical_max = DC_MOTOR_MAX, .offset = 0, .pwm_value = 0, .reverse = false, .complementary = false, .latch = false
        });
        motor_shield_l29xx.M4.EN.PWM = pwm_constructor((PWM_TypeDef) {
            .timer = &htim2, .channel = TIM_CHANNEL_1, .pwm_min = DC_MOTOR_MIN, .pwm_max = DC_MOTOR_MAX, .physical_min = DC_MOTOR_MIN, .physical_max = DC_MOTOR_MAX, .offset = 0, .pwm_value = 0, .reverse = false, .complementary = false, .latch = false
        });

        motor_shield_l29xx.M1.EN.enable_pwm = true;
        motor_shield_l29xx.M2.EN.enable_pwm = true;
        motor_shield_l29xx.M3.EN.enable_pwm = true;
        motor_shield_l29xx.M4.EN.enable_pwm = true;
    }
}

// Initialize the GPIO mode for the motor shield
void ms_gpio_init(enum Motor_Shield_Type type)
{
    if (type == MS_V1) {
        // If using Motor Shield V1
        // The pins are for NUCLEO-L053R8.
        gpio_pin_set(&motor_shield_v1.M1.EN.GPIO, GPIOA, GPIO_PIN_7);
        gpio_pin_set(&motor_shield_v1.M2.EN.GPIO, GPIOB, GPIO_PIN_3);
        gpio_pin_set(&motor_shield_v1.M3.EN.GPIO, GPIOB, GPIO_PIN_10);
        gpio_pin_set(&motor_shield_v1.M4.EN.GPIO, GPIOB, GPIO_PIN_4);

        motor_shield_v1.M1.EN.enable_pwm = false;
        motor_shield_v1.M2.EN.enable_pwm = false;
        motor_shield_v1.M3.EN.enable_pwm = false;
        motor_shield_v1.M4.EN.enable_pwm = false;
    } else if (type == MS_L29XX) {
        // If using Motor Shield L29XX
        // The pins are for NUCLEO-L053R8.
        gpio_pin_set(&motor_shield_l29xx.M1.EN.GPIO, GPIOA, GPIO_PIN_1);
        gpio_pin_set(&motor_shield_l29xx.M2.EN.GPIO, GPIOC, GPIO_PIN_7);
        gpio_pin_set(&motor_shield_l29xx.M3.EN.GPIO, GPIOC, GPIO_PIN_6);
        gpio_pin_set(&motor_shield_l29xx.M4.EN.GPIO, GPIOA, GPIO_PIN_0);

        motor_shield_l29xx.M1.EN.enable_pwm = false;
        motor_shield_l29xx.M2.EN.enable_pwm = false;
        motor_shield_l29xx.M3.EN.enable_pwm = false;
        motor_shield_l29xx.M4.EN.enable_pwm = false;
    }
}

/* Motor_Shield_V1 Control--------------------------------------------------------------*/

// Helper function to get the DC motor object based on the motor shield type and motor number
DC_Motor_TypeDef *get_dc_motor(void *motor_shield, enum Motor_Shield_Type type, uint8_t dc_motor_number)
{
    switch (type) {
    case MS_V1:
        return &(((Motor_Shield_V1 *)motor_shield)->M1) + dc_motor_number;
    case MS_L29XX:
        return &(((Motor_Shield_L29XX *)motor_shield)->M1) + dc_motor_number;
    // Add cases for other motor shield types if necessary
    default:
        return NULL; // If the motor object is not found, exit the function
    }
}

// Helper function to get the bit index of a specific motor
uint8_t get_motor_bit(uint8_t dc_motor_number, uint8_t bit_index)
{
    static const uint8_t motor_bits[4][2] = {{2, 3}, {1, 4}, {5, 7}, {0, 6}};
    return motor_bits[dc_motor_number][bit_index];
}

// Define a function to control the motor direction and speed with one input
void ms_motor_control(void *motor_shield, enum Motor_Shield_Type type, uint8_t dc_motor_number, float motor_input)
{
    DC_Motor_TypeDef *motor = get_dc_motor(motor_shield, type, dc_motor_number);
    if (motor == NULL) {
        return;
    }

    // Apply the reverse setting
    if (motor->reverse) {
        motor_input = -motor_input;
    }

    // Determine the motor direction
    bool forward_rotation = motor_input >= 0;

    // Get the PWM value
    float abs_motor_input = fabs(motor_input);
    int pwm_value;
    if (motor->EN.enable_pwm) {
        pwm_value = (int)map(abs_motor_input, 0, 1, motor->EN.PWM.pwm_min, motor->EN.PWM.pwm_max);
    } else {
        pwm_value = (abs_motor_input > 0) ? 1 : 0;
    }

    // Set PWM or GPIO
    if (motor->EN.enable_pwm) {
        pwm_set(&(motor->EN.PWM), pwm_value, true);
    } else {
        HAL_GPIO_WritePin(motor->EN.GPIO.Port, motor->EN.GPIO.Pin, pwm_value);
    }

    // Set the direction
    if (type == MS_V1) {
        HC595_SendBit(&(((Motor_Shield_V1 *)motor_shield)->hc595), get_motor_bit(dc_motor_number, 0), forward_rotation);
        HC595_SendBit(&(((Motor_Shield_V1 *)motor_shield)->hc595), get_motor_bit(dc_motor_number, 1), !forward_rotation);
    } else if (type == MS_L29XX) {
        HAL_GPIO_WritePin(motor->IN1.Port, motor->IN1.Pin, forward_rotation ? GPIO_PIN_SET : GPIO_PIN_RESET);
        HAL_GPIO_WritePin(motor->IN2.Port, motor->IN2.Pin, forward_rotation ? GPIO_PIN_RESET : GPIO_PIN_SET);
    }
}

// Define a function to control the servo angle with one input
void ms_v1_servo_control(Motor_Shield_V1 *motor_shield, uint8_t servo_number, float servo_input, bool mode) // Add a mode parameter
{
    // Check the validity of the arguments
    if (motor_shield == NULL) {
        return; // Invalid pointer
    }

    // Select the corresponding PWM structure
    PWM_TypeDef *pwm = NULL;

    switch (servo_number) {
    // Use a switch statement to assign different values
    case S1:                           // If servo_number is S1
        pwm = &(motor_shield->S1_PWM); // Select the S1_PWM structure
        break;                         // Break the switch statement
    case S2:                           // If servo_number is S2
        pwm = &(motor_shield->S2_PWM); // Select the S2_PWM structure
        break;                         // Break the switch statement
    default:                           // If servo_number is not valid
        return;                        // Return from the function
    }

    // Check the mode parameter
    if (mode == PWM) {
        // If the mode is PWM
        // Set the PWM value
        pwm_set(pwm, (int)servo_input, true); // Use the pwm_set function
    } else if (mode == ANGLE) {
        // If the mode is ANGLE
        // Set the PWM value according to the servo angle
        pwm_physical_set(pwm, servo_input, true); // Use the pwm_physical_set function
    } else {
        // If the mode is not valid
        return; // Return from the function
    }
}


/* PID Motor Control ---------------------------------------------------------------*/

// // Step 1: Improve the dynamic factor calculation
// float calculate_dynamic_factor(int current_speed, int target_speed)
// {
//     float base_factor;
//     int speed_diff = abs(target_speed - current_speed);
//     int current_magnitude = abs(current_speed);

//     if (target_speed == DC_MOTOR_MIN) {
//         // Faster stopping for higher speeds
//         base_factor = 0.3f + (0.7f * current_magnitude / DC_MOTOR_MAX);
//     } else {
//         // Smoother control for larger speed differences
//         base_factor = 1.0f - (0.8f * speed_diff / DC_MOTOR_MAX);
//     }

//     // Smoother direction changes
//     if ((current_speed > 0 && target_speed < 0) || (current_speed < 0 && target_speed > 0)) {
//         base_factor *= 0.5f;
//     }

//     return fmaxf(MIN_FACTOR, fminf(base_factor, MAX_FACTOR));
// }

// // Step 2: Add a simple PID controller
// PIDController pid;

// void init_pid_controller(PIDController* pid, float Kp, float Ki, float Kd)
// {
//     pid->Kp = Kp;
//     pid->Ki = Ki;
//     pid->Kd = Kd;
//     pid->integral = 0.0f;
//     pid->prev_error = 0.0f;
// }

// float pid_compute(PIDController* pid, float error, float dt)
// {
//     pid->integral += error * dt;
//     float derivative = (error - pid->prev_error) / dt;
//     float output = pid->Kp * error + pid->Ki * pid->integral + pid->Kd * derivative;
//     pid->prev_error = error;
//     return output;
// }


// void pid_motor_control(void *motor_shield, enum Motor_Shield_Type type, uint8_t dc_motor_number, int target_speed, PIDController* pid)
// {
//     DC_Motor_TypeDef *motor = get_dc_motor(motor_shield, type, dc_motor_number);
//     if (motor == NULL) {
//         printf("Error: Motor not found\n");
//         return;
//     }

//     // Limit the target speed
//     target_speed = (target_speed > DC_MOTOR_MAX) ? DC_MOTOR_MAX :
//                    (target_speed < -DC_MOTOR_MAX ? -DC_MOTOR_MAX : target_speed);

//     if (motor->EN.soft_control_delay.IsExpired(&motor->EN.soft_control_delay)) {
//         // Calculate dynamic factor
//         float factor = calculate_dynamic_factor(motor->current_speed, target_speed);

//         // Calculate error
//         float error = target_speed - motor->current_speed;

//         // Compute PID output
//         float pid_output = pid_compute(pid, error, 0.02f);  // Assuming 20ms update interval

//         // Combine dynamic factor and PID
//         int speed_change = (int)((error * factor) + pid_output);

//         // Update current speed
//         motor->current_speed += speed_change;

//         // Ensure speed is within limits
//         motor->current_speed = fmaxf(-DC_MOTOR_MAX, fminf(motor->current_speed, DC_MOTOR_MAX));

//         // Convert to motor input (-1 to 1 float) and control
//         float motor_input = (float)motor->current_speed / (float)DC_MOTOR_MAX;
//         ms_motor_control(motor_shield, type, dc_motor_number, motor_input);

//         // Set next update delay
//         motor->EN.soft_control_delay.Start(&motor->EN.soft_control_delay, 20);
//     }
// }




/* Soft Motor Control ---------------------------------------------------------------*/

float apply_deadband_compensation(float input) {
    float deadband = 0.05f;  // Adjust based on your motor's characteristics
    if (fabsf(input) < deadband) {
        return 0.0f;
    }
    return input > 0 ? input - deadband : input + deadband;
}

float apply_non_linear_control(float input) {
    // Apply more aggressive control at low speeds
    return powf(fabsf(input), 0.8f) * (input >= 0 ? 1 : -1);
}


void soft_motor_control(void *motor_shield, enum Motor_Shield_Type type, uint8_t dc_motor_number, int target_speed)
{
    DC_Motor_TypeDef *motor = get_dc_motor(motor_shield, type, dc_motor_number);
    if (motor == NULL) {
        printf("Error: Motor not found\n");
        return;
    }

    // Limit the target speed to between -DC_MOTOR_MAX and DC_MOTOR_MAX
    target_speed = (target_speed > DC_MOTOR_MAX) ? DC_MOTOR_MAX : (target_speed < -DC_MOTOR_MAX ? -DC_MOTOR_MAX : target_speed);

    // Update the target speed
    motor->target_speed = target_speed;

    if (motor->EN.soft_control_delay.IsExpired(&motor->EN.soft_control_delay)) {
        float speed_diff = motor->target_speed - motor->current_speed;
        float acceleration_factor = 0.1f; // Slower acceleration
        float deceleration_factor = 0.5f; // Faster deceleration

        // Calculate the new current speed
        if (fabsf(speed_diff) > 1.0f) {
            float change_factor;
            if ((motor->current_speed >= 0 && target_speed > motor->current_speed) ||
                (motor->current_speed <= 0 && target_speed < motor->current_speed)) {
                // Accelerating
                change_factor = acceleration_factor;
            } else {
                // Decelerating
                change_factor = deceleration_factor;
            }
            
            // Apply non-linear control for low speeds
            float adjusted_diff = apply_non_linear_control(speed_diff / DC_MOTOR_MAX) * DC_MOTOR_MAX;
            motor->current_speed += (int)(adjusted_diff * change_factor);
        } else {
            motor->current_speed = motor->target_speed;
        }

        // Convert the current speed to motor input (-1 to 1 float)
        float motor_input = (float)motor->current_speed / (float)DC_MOTOR_MAX;

        // Apply deadband compensation
        motor_input = apply_deadband_compensation(motor_input);

        // Ensure minimum start power
        if (motor_input != 0 && fabsf(motor_input) < MIN_START_POWER) {
            motor_input = (motor_input > 0) ? MIN_START_POWER : -MIN_START_POWER;
        }

        // Call ms_motor_control to actually control the motor
        ms_motor_control(motor_shield, type, dc_motor_number, motor_input);

        // Set the delay for the next update (e.g. 20ms for faster updates)
        motor->EN.soft_control_delay.Start(&motor->EN.soft_control_delay, 20);
    }
}